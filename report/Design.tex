\section{Design \& Implementation}

\begin{itemize}
  \item Connect to background with the trees
  \item Explain autotuning in more detail than the introduction.
    \item write the autotuning part of the introduction so they connect.
  \item Explain what it means to do an exhaustive search
  \item Explain the idea behind how we perform an exhaustive search.
    \item Look at previous project 'comparison based tuner'
\end{itemize}

\subsection{Auto-tuning in Introduction}
in broad terms auto-tuning is the process of automatically tuning a set of
parameters so as to optimize some aspect of the program when run. This
process can be done both at compile- or runtime, but in the case of Futhark,
and this report it's done at runtime. In our, and most other, cases this aspect
we are trying to optimize will be the runtime, that we are trying to minimize. 


\subsection{Auto-tuning in Futhark} % Might just be the intro to this section
In the case of auto-tuning Futhark the goal is to find the configuration of 
threshold parameters that will optimize the running time of the program for 
on a set of inputs given by the user. As we have seen in section \textbf{BACKGROUND}
the values that are choosen for the thresholds parameters decide which code
version is used for a given input. So the goal is to pick the values for the
threshold parameters that will result in the different inputs ending in the
code version that is optimal for their size.

\subsection{Searching for the opimal threshold values}
% Maybe mention how the old tuner solved this problem
There are many ways you could choose to search for the optimal paths, in this
report we have implemented the most simple version, an exhaustive search. An
exhaustive search is simply about looking through all combinations and choosing
the best one. Of course it's not possible to try all combinations of all numbers
that fit within the threshold parameter data type this would take far too long. 
% Include a calculation to show the point.
To solve this problem the search space needs to be bounded to reduce the number
of combination that has to be checked. The way to do this is to use the
information available about the structure of threshold parameters, to make sure
that only values that would result in a different code version being run for 
one of the data sets. 

\section{Another version of everything}
\subsection{Building the Tree}
Every, compiled, Futhark program can be given a flag so the thresholds, and their structure, is printed out. The syntax of the string representing each threshold parameter
can be seen in Figure \ref{thresholdSyntax}.
\begin{figure}[h]
	$$\underbrace{\texttt{main.suff\_outer\_par\_6}}_\text{threshold parameter \#6} \overbrace{\texttt{(threshold (!main.suff\_outer\_par\_4} \underbrace{\texttt{!main.suff\_intra\_par\_5))}}_\text{(!) indicates a false comparison}}^\text{list of thresholds that \#6 is dependent on}$$
	\caption{The syntax of thresholds, printed by Futhark.}
	\label{thresholdSyntax}
\end{figure}
We translate the list of these strings into a tree structure similar to the
trees we have see in Section \ref{BabyGotBack}. 
We start by finding the thresholds that does not depend on any other thresholds
being true or false, in order for them to be evaluated, this will make them root nodes in their respective trees. Currently there will only exist one of these root nodes, but in order to make the program
adaptable to future changes to the compiler, we take into account, the possibility that the
structure of the thresholds will exhibit a forest. In order to process a forest, in the same way we would a tree, 
we create a root node that has no useful information, but will simply be the
parent of the forest. \\

To construct the rest of the tree we execute recursively on all the children
of the previous node finding one who has the same dependencies as the current
node, but also depends on the current node itself. All of these are made
children of the current node, and the function is executed on each of them. The
recursion ends when no children are found for a node.

Unlike the theoretical trees, seen previously, the implemented trees cannot carry information on
the edges themselves, this means the information is instead encoded in the
children. So each node is a tuple containing the name of the threshold
parameter and a boolean denoting the result of the parents threshold
comparison that lead to the node. The process of constructing the tree can be seen in Figure \ref{buildThresTree}.
\input{recursionTree}

While this solution works currently, a change in the Futhark compiler could
result in nodes having multiple parents, and therefore requiring more
information than a single boolean. This problem can be solved quite simply by
duplicating the problematic subtree, thereby having a version of the subtree that came from a
comparisons being true, and one for comparisons being false.

\subsection{Exhaustive Search}
An exhaustive search is simply trying every possible element of the search space, 
to find a certain element, based on some motivation. In our case we are searching in the set of possible 
threshold configurations, with the motivation of finding the configuration that results in the lowest running time. If we knew nothing about
the thresholds, or their structure we would have to try every configuration of
numbers between 0 and whatever the highest number their implementation allows. 
With a simple program such a matrix-matrix multiplication (which has 4 thresholds, see Figure \ref{MatMultTreeFilled}), and assuming an upper limit of $2^{15}$ which is the threshold default, and therefore a conservative limit,
we would end up with $\left(2^{15}\right)^4 \approx 1.153\times10^{18}$ configurations.
This search would obviously take far longer than any of us would be alive, so we need a way to limit the search space.
\\
They way we limit the search space is by using our knowledge of the threshold
parameters and only trying values that would result in a different set of code 
version being executed on at least one of the datasets. More specifically, we will
use the knowledge that the comparisons are of the form
(\texttt{Threshold\_value <= comparison\_value}). Since the
\texttt{comparison\_value} is constant for a certain dataset there are effectively
only two different threshold values that need to be checked for one threshold 
in isolation. One where it's equal to the \texttt{comparison\_value} and one
where it's $\texttt{comparison\_value} + 1$, as these will result in true and
false respectively, with those being the only options.
Of course the thresholds are not in isolation, but structured as we've seen
Figure \ref{LocVolCalibTree} for example, so some comparison result in earlier 
thresholds will make later thresholds in the tree redundant, as they are never compared. We can see this idea in Figure \ref{redundant}
\input{redundantThres}
One thing that is also important is that we are tuning with multiple datasets,
so we can't just think of all the unique paths through one tree. Instead we
need to think of each dataset as having it's own tree, with it's own 
\texttt{comparison\_value} for each threshold. This means the search space is
not every unique path through the tree, but every possible unique combination
of paths through the many trees we now have. 
\input{combinationTree}

\subsection{Identifying all unique combinations}
The values that the thresholds are compared to in each dataset are extracted,
to a list of values for each threshold. Then they are sorted and duplicates are
removed. Since the comparisons are all less than or equal
(\texttt{Threshold\_value <= comparison\_value}) comparisons the we can simply
pick the smallest \texttt{comparison\_value} and be sure that the comparison
will result in true for all our dataset. It's also possible to construct a
value that will guarantee that the comparison will result in false. We do this
by simply taking the largest value for each threshold, were all but the largest
dataset will result in false, and incrementing it by one. This will mean it
will also result in false for the largest dataset. We put this false-value at
the end of the list of values we extracted from the program. We are left with a
list of values for each threshold, the first value will make the comparison for
every dataset result in true, the last will make the comparison result in false
for every dataset, and the values between will result in true for some, and
false for others. These values are then put on their corresponding threshold in
the tree we've constructed.
\\
% Need to create some example figure to go through.


